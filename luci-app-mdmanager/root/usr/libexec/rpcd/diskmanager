#!/bin/sh

. /usr/share/libubox/jshn.sh

##################################################################################################################
#
#  Copyright 2025 Rafał Wabik - IceG - From eko.one.pl forum
#  
#  MIT License
#  
##################################################################################################################

LOG_FILE="/tmp/diskmanager.log"
PID_FILE="/tmp/diskmanager.pid"
RESULT_FILE="/tmp/diskmanager.result"

##################################################################################################################
# LOGGING / LOGOWANIE
##################################################################################################################
log_msg() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

##################################################################################################################
# MOUNT DETECTION / WYKRYWANIE MONTOWANIA
##################################################################################################################
is_device_mounted() {
    device="$1"
    grep -q "^${device} " /proc/mounts 2>/dev/null
    return $?
}

##################################################################################################################
# PARTITION SUFFIX DETECTOR / DETEKTOR SUFIKSU PARTYCJI
# (sda1 vs nvme0n1p1)
##################################################################################################################
part_suffix() {
    dev="$1"
    case "$(basename "$dev")" in
        *[0-9]) echo "p" ;;
        *) echo "" ;;
    esac
}

##################################################################################################################
# PARSE PARTITION NAME / PARSOWANIE NAZWY PARTYCJI
# Extracts device and partition number / Wyodrębnia urządzenie i numer partycji
##################################################################################################################
parse_partition_name() {
    partition="$1"
    # For /dev/sda1 -> DEVICE=/dev/sda NUM=1
    # For /dev/nvme0n1p1 -> DEVICE=/dev/nvme0n1 NUM=1
    if echo "$partition" | grep -qE 'p[0-9]+$'; then
        # nvme style
        DEVICE=$(echo "$partition" | sed -E 's/p[0-9]+$//')
        NUM=$(echo "$partition" | sed -E 's/.*p([0-9]+)$/\1/')
    else
        # sda style
        DEVICE=$(echo "$partition" | sed -E 's/[0-9]+$//')
        NUM=$(echo "$partition" | sed -E 's/.*([0-9]+)$/\1/')
    fi
    export DEVICE NUM
}

##################################################################################################################
# UNMOUNTING PARTITIONS / ODMONTOWYWANIE PARTYCJI
##################################################################################################################
unmount_device() {
    device="$1"
    log_msg "Unmounting partitions for $device / Odmontowywanie partycji dla $device"

    suffix=$(part_suffix "$device")

    if [ -n "$suffix" ]; then
        pattern="${device}${suffix}[0-9]*"
    else
        pattern="${device}[0-9]*"
    fi

    for part in $pattern; do
        if [ -b "$part" ] && [ "$part" != "$device" ]; then
            if is_device_mounted "$part"; then
                log_msg "Unmounting $part / Odmontowywanie $part"
                umount -l "$part" >> "$LOG_FILE" 2>&1 || umount -f "$part" >> "$LOG_FILE" 2>&1
                sleep 1
            fi
        fi
    done

    grep "^$device" /proc/mounts | while read dev mp rest; do
        log_msg "Force unmounting $dev from $mp / Wymuszanie odmontowania $dev z $mp"
        umount -l "$dev" >> "$LOG_FILE" 2>&1 || umount -f "$dev" >> "$LOG_FILE" 2>&1
        sleep 1
    done
}

##################################################################################################################
# KERNEL PARTITION TABLE REFRESH / ODŚWIEŻANIE TABLICY PARTYCJI
##################################################################################################################
refresh_partitions() {
    device="$1"
    log_msg "Refreshing partition table for $device / Odświeżanie tablicy partycji dla $device"

    if command -v blockdev >/dev/null 2>&1; then
        blockdev --rereadpt "$device" >> "$LOG_FILE" 2>&1 || true
    fi

    if command -v partprobe >/dev/null 2>&1; then
        partprobe "$device" >> "$LOG_FILE" 2>&1 || true
    fi

    base_name=$(basename "$device")
    if [ -w "/sys/block/$base_name/device/rescan" ]; then
        echo 1 > "/sys/block/$base_name/device/rescan" 2>/dev/null || true
    fi

    sleep 1
}

##################################################################################################################
# WAIT FOR BLOCK DEVICE / OCZEKIWANIE NA URZĄDZENIE BLOKOWE
##################################################################################################################
wait_for_partition() {
    partition="$1"
    max_wait=${2:-10}
    count=0

    log_msg "Waiting for $partition to appear... / Oczekiwanie na pojawienie się $partition..."

    while [ $count -lt $max_wait ]; do
        if [ -b "$partition" ]; then
            log_msg "Partition $partition appeared / Partycja $partition pojawiła się"
            return 0
        fi
        sleep 1
        count=$((count + 1))
    done

    log_msg "Timeout waiting for $partition / Przekroczono czas oczekiwania na $partition"
    return 1
}

##################################################################################################################
# GET LAST PARTITION NUMBER / POBIERZ NUMER OSTATNIEJ PARTYCJI
##################################################################################################################
get_last_partition_number() {
    device="$1"
    /sbin/parted -s -m "$device" print 2>/dev/null | awk -F: '/^[0-9]+:/ {x=$1} END{print x}'
}

##################################################################################################################
# CHECK IF DISK HAS PARTITIONS / SPRAWDŹ CZY DYSK MA PARTYCJE
##################################################################################################################
disk_has_partitions() {
    device="$1"
    count=$(/sbin/parted -s -m "$device" print 2>/dev/null | awk -F: '/^[0-9]+:/ {count++} END{print count+0}')
    [ "$count" -gt 0 ]
    return $?
}

##################################################################################################################
# FIND FREE SPACE REGION ON DISK / ZNAJDŹ WOLNĄ PRZESTRZEŃ NA DYSKU
##################################################################################################################
find_free_space() {
    device="$1"
    
    log_msg "DEBUG: Searching for free space on $device / Szukanie wolnej przestrzeni na $device"
    
    # Get all free regions / Pobierz wszystkie wolne regiony
    free=$(/sbin/parted -s -m "$device" unit s print free 2>/dev/null | grep "free;")
    
    log_msg "DEBUG: Free regions found / Znalezione wolne regiony: $free"
    
    # Find the largest free region / Znajdź największy wolny region
    result=$(echo "$free" | awk -F: '
        BEGIN {
            max = 0
            best_start = ""
            best_end = ""
        }
        /free/ {
            start=$2; end=$3; size=$4
            gsub("s","",start); gsub("s","",end); gsub("s","",size)
            
            # Convert to numbers / Konwersja na liczby
            start = start + 0
            end = end + 0
            size = size + 0
            
            # Skip tiny regions (less than 2048 sectors = 1MB)
            # Pomiń małe regiony (mniej niż 2048 sektorów = 1MB)
            if (size < 2048) {
                next
            }
            
            # Track largest region / Śledź największy region
            if (size > max) { 
                max = size
                best_start = start
                best_end = end
            }
        }
        END { 
            if (max > 0) {
                printf "%s:%s:%s", best_start, best_end, max
            }
        }
    ')
    
    log_msg "DEBUG: find_free_space result / Wynik find_free_space: '$result'"
    echo "$result"
}

##################################################################################################################
# PARTED WRAPPER ALWAYS NON-INTERACTIVE / WRAPPER PARTED ZAWSZE NIE-INTERAKTYWNY
##################################################################################################################
parted_cmd() {
    /sbin/parted -s -- "$@"
}

##################################################################################################################
# MAP FILESYSTEM TYPE FOR PARTED / MAPOWANIE TYPU SYSTEMU PLIKÓW DLA PARTED
# Parted uses different names than mkfs - need to map them
# Parted używa innych nazw niż mkfs - trzeba je zmapować
##################################################################################################################
map_fstype_for_parted() {
    fstype="$1"
    case "$fstype" in
        vfat|fat32) echo "fat32" ;;
        fat16) echo "fat16" ;;
        exfat) echo "fat32" ;;  # exfat not supported by parted, use fat32 as placeholder / nie jest wspierany przez parted
        swap) echo "linux-swap" ;;
        ext2|ext3|ext4|ntfs|hfs|hfs+|hfsx) echo "$fstype" ;;
        *) echo "ext2" ;;  # default ext2 as safe fallback / domyślnie ext2 jako bezpieczny fallback
    esac
}

##################################################################################################################
# ZERO OUT PARTITION OR DISK START / WYZERUJ POCZĄTEK PARTYCJI LUB DYSKU
##################################################################################################################
zero_device_start() {
    target="$1"
    size_kb="${2:-10240}"  # default 10MB / domyślnie 10MB
    
    log_msg "Zeroing first ${size_kb}KB of $target / Zerowanie pierwszych ${size_kb}KB z $target"
    
    if [ ! -b "$target" ]; then
        log_msg "Device $target not found, skipping zero / Urządzenie $target nie znalezione, pomijanie zerowania"
        return 0
    fi
    
    # Get size from /proc/partitions / Pobierz rozmiar z /proc/partitions
    actual_size=$(grep "$(basename "$target")$" /proc/partitions 2>/dev/null | awk '{print $3}')
    
    if [ -n "$actual_size" ] && [ "$actual_size" -gt 0 ]; then
        if [ "$actual_size" -lt "$size_kb" ]; then
            # If partition is smaller than 10MB, zero it completely
            # Jeśli partycja jest mniejsza niż 10MB, wyzeruj całkowicie
            dd if=/dev/zero of="$target" bs=1K count="$actual_size" >> "$LOG_FILE" 2>&1 || true
        else
            # Zero first 10MB / Wyzeruj pierwsze 10MB
            dd if=/dev/zero of="$target" bs=1M count=10 >> "$LOG_FILE" 2>&1 || true
        fi
    else
        # Fallback: try to zero 10MB / Zabezpieczenie: spróbuj wyzerować 10MB
        dd if=/dev/zero of="$target" bs=1M count=10 >> "$LOG_FILE" 2>&1 || true
    fi
    
    sync
    sleep 1
}

##################################################################################################################
# CREATE PARTITION / TWORZENIE PARTYCJI
##################################################################################################################
# Arguments / Argumenty:
#   $1 - disk: base disk device / urządzenie bazowe dysku (np. /dev/sda, /dev/nvme0n1)
#   $2 - type: partition type / typ partycji (primary | extended | logical)
#   $3 - fstype: placeholder for filesystem type / placeholder dla typu systemu plików (np. ext2, ext4)
#   $4 - size_param: size / rozmiar ('123MB' / '1GB' / '100%' / '1114656768s')
#   $5 - layout: partitioning scheme / schemat partycjonowania ('gpt' lub 'msdos')
#   $6 - label: optional label / opcjonalna etykieta
##################################################################################################################
create_partition_impl() {
    disk="$1"       # Base device / Urządzenie bazowe: /dev/sda lub /dev/nvme0n1
    type="$2"       # primary | extended | logical
    fstype="$3"     # placeholder FS type / typ systemu plików (np. ext2)
    size_param="$4" # number in MB or / liczba MB lub '123MB' / '1GB' / '100%' / '1114656768s'
    layout="$5"     # 'gpt' or 'msdos' (msdos = mbr)
    label="$6"      # optional label / opcjonalna etykieta

    log_msg "=== Creating partition on $disk / Tworzenie partycji na $disk ==="
    log_msg "Params / Parametry: type=$type fstype=$fstype size=$size_param layout=$layout label=$label"

    # Safety checks / Sprawdzenia bezpieczeństwa
    if [ ! -b "$disk" ]; then
        log_msg "Device $disk not found! / Urządzenie $disk nie znalezione!"
        echo 1 > "$RESULT_FILE"
        return 1
    fi

    # Unmount device partitions / Odmontuj partycje urządzenia
    unmount_device "$disk"

    # Ensure partition table exists / Upewnij się, że tablica partycji istnieje
    parted_out=$(/sbin/parted -s "$disk" print 2>&1 || true)
    # Check for signs of missing partition table / Sprawdź oznaki braku tablicy partycji
    if echo "$parted_out" | grep -qi "unrecognised disk label\|unrecognized disk label"; then
        log_msg "Disk has no partition table, creating $layout / Dysk nie ma tablicy partycji, tworzenie $layout"
        label_type="msdos"
        [ "$layout" = "gpt" ] && label_type="gpt"
        parted_cmd "$disk" mklabel "$label_type" >> "$LOG_FILE" 2>&1
        rc=$?
        if [ $rc -ne 0 ]; then
            log_msg "Failed to create partition table (rc=$rc) / Nie udało się utworzyć tablicy partycji (rc=$rc)"
            echo $rc > "$RESULT_FILE"
            return $rc
        fi
        log_msg "Partition table $label_type created successfully / Tablica partycji $label_type utworzona pomyślnie"
        refresh_partitions "$disk"
        parted_out=$(/sbin/parted -s "$disk" print 2>&1 || true)
    elif ! echo "$parted_out" | grep -q "Partition Table:"; then
        log_msg "No partition table found, creating $layout / Nie znaleziono tablicy partycji, tworzenie $layout"
        label_type="msdos"
        [ "$layout" = "gpt" ] && label_type="gpt"
        parted_cmd "$disk" mklabel "$label_type" >> "$LOG_FILE" 2>&1
        rc=$?
        if [ $rc -ne 0 ]; then
            log_msg "Failed to create partition table (rc=$rc) / Nie udało się utworzyć tablicy partycji (rc=$rc)"
            echo $rc > "$RESULT_FILE"
            return $rc
        fi
        log_msg "Partition table $label_type created successfully / Tablica partycji $label_type utworzona pomyślnie"
        refresh_partitions "$disk"
        parted_out=$(/sbin/parted -s "$disk" print 2>&1 || true)
    fi

    # Find free region / Znajdź wolny region
    free_space=$(find_free_space "$disk")
    
    log_msg "DEBUG: free_space variable value / Wartość zmiennej free_space: '$free_space'"
    
    if [ -n "$free_space" ]; then
        free_start=$(echo "$free_space" | cut -d: -f1)
        free_end=$(echo "$free_space" | cut -d: -f2)
        free_size=$(echo "$free_space" | cut -d: -f3)
        
        # Validate we got valid numbers / Walidacja poprawnych liczb
        if [ -n "$free_start" ] && [ -n "$free_end" ] && [ "$free_start" -lt "$free_end" ] 2>/dev/null; then
            log_msg "Found free region / Znaleziono wolny region: ${free_start}s - ${free_end}s (size/rozmiar: ${free_size}s)"
            
            # Align free_start to 2048 sectors (1MB) for proper alignment
            # Wyrównaj free_start do 2048 sektorów (1MB) dla prawidłowego wyrównania
            if [ "$free_start" -lt 2048 ]; then
                free_start=2048
                log_msg "Adjusted free_start to 2048s for proper alignment / Dostosowano free_start do 2048s dla prawidłowego wyrównania"
            else
                # Round up to nearest multiple of 2048 / Zaokrąglij w górę do najbliższej wielokrotności 2048
                remainder=$((free_start % 2048))
                if [ $remainder -ne 0 ]; then
                    free_start=$((free_start + 2048 - remainder))
                    log_msg "Adjusted free_start to ${free_start}s for proper alignment / Dostosowano free_start do ${free_start}s dla wyrównania"
                fi
            fi
            
            # Check if we still have space after alignment / Sprawdź czy nadal mamy miejsce po wyrównaniu
            if [ "$free_start" -ge "$free_end" ]; then
                log_msg "ERROR: No space left after alignment / BŁĄD: Brak miejsca po wyrównaniu"
                echo 1 > "$RESULT_FILE"
                return 1
            fi
        else
            log_msg "Invalid free space values, will use fallback / Nieprawidłowe wartości wolnej przestrzeni, użyje fallback"
            free_space=""
        fi
    fi
    
    # Fallback if no valid free space found / Zabezpieczenie jeśli nie znaleziono prawidłowej wolnej przestrzeni
    if [ -z "$free_space" ]; then
        log_msg "No free space found by parted, calculating disk size manually / Nie znaleziono wolnej przestrzeni przez parted, ręczne obliczanie rozmiaru dysku"
        
        # Method 1: Try blockdev / Metoda 1: Spróbuj blockdev
        total_sectors=$(blockdev --getsz "$disk" 2>/dev/null || true)
        
        # Method 2: Try /sys/block / Metoda 2: Spróbuj /sys/block
        if [ -z "$total_sectors" ] || [ "$total_sectors" = "0" ]; then
            base_name=$(basename "$disk")
            if [ -f "/sys/block/$base_name/size" ]; then
                total_sectors=$(cat "/sys/block/$base_name/size" 2>/dev/null || true)
            fi
        fi
        
        # Method 3: Try parted (after table creation) / Metoda 3: Spróbuj parted (po utworzeniu tablicy)
        if [ -z "$total_sectors" ] || [ "$total_sectors" = "0" ]; then
            total_sectors=$(/sbin/parted -s -m "$disk" unit s print 2>/dev/null | awk -F: -v dev="$(basename "$disk")" '$1==dev{print $2}' | sed 's/s$//' || true)
        fi
        
        # Method 4: Try fdisk fallback / Metoda 4: Zabezpieczenie fdisk
        if [ -z "$total_sectors" ] || [ "$total_sectors" = "0" ]; then
            total_sectors=$(fdisk -l "$disk" 2>/dev/null | awk '/^Disk \/dev\// && /bytes/ {gsub(",","",$5); print int($5/512)}' | head -1 || true)
        fi
        
        if [ -z "$total_sectors" ] || [ "$total_sectors" = "0" ]; then
            log_msg "Cannot determine disk size / Nie można określić rozmiaru dysku"
            echo 1 > "$RESULT_FILE"
            return 1
        fi
        
        log_msg "Disk size determined / Określono rozmiar dysku: $total_sectors sectors/sektorów"
        
        # Reserve GPT backup if needed / Zarezerwuj backup GPT jeśli potrzeba
        if [ "$layout" = "gpt" ]; then
            free_start=2048
            free_end=$((total_sectors - 34))
        else
            free_start=2048
            free_end=$((total_sectors - 1))
        fi
        log_msg "Using default free area / Używanie domyślnego wolnego obszaru: ${free_start}s - ${free_end}s"
    fi  # End of fallback if / Koniec fallback if

    # Interpret size_param -> compute end sector or pass-through (% or s)
    # Interpretuj size_param -> oblicz sektor końcowy lub przekaż (% lub s)
    case "$size_param" in
        *%|*s)
            partition_end="$size_param"
            ;;
        *MB|*mb)
            mb=$(echo "$size_param" | sed -E 's/[Mm][Bb]$//')
            secs=$(( mb * 1024 * 1024 / 512 ))
            partition_end="$(( free_start + secs ))s"
            ;;
        *GB|*gb)
            gb=$(echo "$size_param" | sed -E 's/[Gg][Bb]$//')
            secs=$(( gb * 1024 * 1024 * 1024 / 512 ))
            partition_end="$(( free_start + secs ))s"
            ;;
        *)
            if echo "$size_param" | grep -qE '^[0-9]+$'; then
                # Numeric treated as MB (backwards compatibility) / Liczba traktowana jako MB (kompatybilność wsteczna)
                mb=$size_param
                secs=$(( mb * 1024 * 1024 / 512 ))
                partition_end="$(( free_start + secs ))s"
            else
                # Unknown, use free_end / Nieznane, użyj free_end
                partition_end="${free_end}s"
            fi
            ;;
    esac

    # If partition_end is numeric sector without trailing s add s
    # Jeśli partition_end jest numerycznym sektorem bez końcowego s dodaj s
    case "$partition_end" in
        *s) ;; # ok
        *%) ;; # ok percent
        *) partition_end="${partition_end}s" ;;
    esac

    # If computed partition_end exceeds free_end (only if numeric), cap it
    # Jeśli obliczony partition_end przekracza free_end (tylko jeśli numeryczny), ogranicz go
    if echo "$partition_end" | grep -qE '^[0-9]+s$'; then
        num_end=$(echo "$partition_end" | sed 's/s$//')
        if [ -n "$free_end" ] && [ "$num_end" -gt "$free_end" ] 2>/dev/null; then
            log_msg "Requested end $num_end > free_end $free_end, capping to free_end / Żądany koniec $num_end > free_end $free_end, ograniczanie do free_end"
            partition_end="${free_end}s"
        fi
    fi

    log_msg "Creating partition type=$type from ${free_start}s to ${partition_end} / Tworzenie partycji type=$type od ${free_start}s do ${partition_end}"

    # Handle logical partitions: ensure extended exists or create it
    # Obsługa partycji logicznych: upewnij się że rozszerzona istnieje lub utwórz ją
    if [ "$type" = "logical" ]; then
        # Force refresh before checking for extended / Wymuś odświeżenie przed sprawdzeniem rozszerzonej
        log_msg "Refreshing partition table before checking for extended / Odświeżanie tablicy partycji przed sprawdzeniem rozszerzonej"
        refresh_partitions "$disk"
        sleep 1
        
        # Debug: show what parted returns / Debug: pokaż co zwraca parted
        parted_machine=$(/sbin/parted -s -m "$disk" print 2>/dev/null || true)
        parted_regular=$(/sbin/parted -s "$disk" print 2>/dev/null || true)
        log_msg "DEBUG parted -m output: $parted_machine"
        log_msg "DEBUG parted regular output (grep extended): $(echo "$parted_regular" | grep -i extended || echo 'NO MATCH')"
        
        # Check if any extended partition exists / Sprawdź czy istnieje partycja rozszerzona
        ext_exists=""
        
        # Method 1: Check parted machine format column 5 / Metoda 1: Sprawdź parted format maszynowy kolumna 5
        ext_exists=$(/sbin/parted -s -m "$disk" print 2>/dev/null | awk -F: '/^[0-9]+:/ && tolower($5) ~ /extended/ {print $1}' | head -1 || true)
        log_msg "DEBUG Method 1 (col 5): ext_exists='$ext_exists'"
        
        # Method 2: If empty, try column 6 (some parted versions) / Metoda 2: Jeśli puste, spróbuj kolumna 6
        if [ -z "$ext_exists" ]; then
            ext_exists=$(/sbin/parted -s -m "$disk" print 2>/dev/null | awk -F: '/^[0-9]+:/ && tolower($6) ~ /extended/ {print $1}' | head -1 || true)
            log_msg "DEBUG Method 2 (col 6): ext_exists='$ext_exists'"
        fi
        
        # Method 3: If still empty, try regular parted output / Metoda 3: Jeśli nadal puste, spróbuj zwykłego parted
        if [ -z "$ext_exists" ]; then
            ext_exists=$(/sbin/parted -s "$disk" print 2>/dev/null | awk '/[Ee]xtended/ {print $1}' | head -1 || true)
            log_msg "DEBUG Method 3 (regular): ext_exists='$ext_exists'"
        fi
        
        log_msg "Extended partition check FINAL / Sprawdzenie partycji rozszerzonej FINALNE: ext_exists='$ext_exists'"
        
        if [ -n "$ext_exists" ]; then
            log_msg "Extended partition $ext_exists already exists, will create logical inside it / Partycja rozszerzona $ext_exists już istnieje, utworzę logiczną wewnątrz"
            # Extended already exists - find free space inside it / Rozszerzona już istnieje - znajdź wolną przestrzeń wewnątrz
            free_space=$(find_free_space "$disk")
            if [ -n "$free_space" ]; then
                free_start=$(echo "$free_space" | cut -d: -f1)
                free_end=$(echo "$free_space" | cut -d: -f2)
                
                # Align free_start for logical partition / Wyrównaj free_start dla partycji logicznej
                remainder=$((free_start % 2048))
                if [ $remainder -ne 0 ]; then
                    free_start=$((free_start + 2048 - remainder))
                    log_msg "Adjusted logical free_start to ${free_start}s for alignment / Dostosowano logiczny free_start do ${free_start}s dla wyrównania"
                fi
                
                log_msg "Free space inside extended / Wolna przestrzeń wewnątrz rozszerzonej: ${free_start}s - ${free_end}s"
                
                # Recalculate partition_end if it exceeds free_end / Przelicz partition_end jeśli przekracza free_end
                if echo "$partition_end" | grep -qE '^[0-9]+s$'; then
                    num_end=$(echo "$partition_end" | sed 's/s$//')
                    if [ -n "$free_end" ] && [ "$num_end" -gt "$free_end" ] 2>/dev/null; then
                        log_msg "Requested end $num_end > free_end $free_end inside extended, capping / Żądany koniec $num_end > free_end $free_end wewnątrz rozszerzonej, ograniczanie"
                        partition_end="${free_end}s"
                    fi
                fi
            else
                log_msg "ERROR: No free space found inside extended partition / BŁĄD: Nie znaleziono wolnej przestrzeni wewnątrz partycji rozszerzonej"
                echo 1 > "$RESULT_FILE"
                return 1
            fi
        else
            # Extended doesn't exist - need to create it / Rozszerzona nie istnieje - trzeba ją utworzyć
            log_msg "No extended partition found — creating extended from ${free_start}s to ${free_end}s / Nie znaleziono partycji rozszerzonej — tworzenie rozszerzonej od ${free_start}s do ${free_end}s"
            parted_cmd "$disk" mkpart extended "${free_start}s" "${free_end}s" >> "$LOG_FILE" 2>&1
            rc=$?
            if [ $rc -ne 0 ]; then
                log_msg "Failed to create extended partition (rc=$rc) / Nie udało się utworzyć partycji rozszerzonej (rc=$rc)"
                echo $rc > "$RESULT_FILE"
                refresh_partitions "$disk"
                return $rc
            fi
            refresh_partitions "$disk"
            # Recalc free_space inside extended for logical creation / Przelicz free_space wewnątrz rozszerzonej dla utworzenia logicznej
            free_space=$(find_free_space "$disk")
            if [ -n "$free_space" ]; then
                free_start=$(echo "$free_space" | cut -d: -f1)
                free_end=$(echo "$free_space" | cut -d: -f2)
                
                # Align free_start for logical partition / Wyrównaj free_start dla partycji logicznej
                remainder=$((free_start % 2048))
                if [ $remainder -ne 0 ]; then
                    free_start=$((free_start + 2048 - remainder))
                    log_msg "Adjusted logical free_start to ${free_start}s for alignment / Dostosowano logiczny free_start do ${free_start}s dla wyrównania"
                fi
                
                log_msg "After extended / Po rozszerzonej: free region / wolny region ${free_start}s - ${free_end}s"
            fi
        fi
        # Create logical with requested end inside extended / Utwórz logiczną z żądanym końcem wewnątrz rozszerzonej
        parted_fstype=$(map_fstype_for_parted "$fstype")
        log_msg "Creating logical partition / Tworzenie partycji logicznej: parted $disk mkpart logical $parted_fstype ${free_start}s ${partition_end}"
        parted_cmd "$disk" mkpart logical "$parted_fstype" "${free_start}s" "${partition_end}" >> "$LOG_FILE" 2>&1
        rc=$?
    else
        # Create primary/extended as requested / Utwórz primary/extended jak żądano
        case "$type" in
            extended)
                parted_cmd "$disk" mkpart extended "${free_start}s" "${partition_end}" >> "$LOG_FILE" 2>&1
                rc=$?
                ;;
            primary|p|primary)
                parted_fstype=$(map_fstype_for_parted "$fstype")
                log_msg "Creating primary partition with fstype / Tworzenie partycji primary z fstype: $parted_fstype (original: $fstype)"
                parted_cmd "$disk" mkpart primary "$parted_fstype" "${free_start}s" "${partition_end}" >> "$LOG_FILE" 2>&1
                rc=$?
                ;;
            *)
                # Default to primary / Domyślnie primary
                parted_fstype=$(map_fstype_for_parted "$fstype")
                log_msg "Creating default primary partition with fstype / Tworzenie domyślnej partycji primary z fstype: $parted_fstype (original: $fstype)"
                parted_cmd "$disk" mkpart primary "$parted_fstype" "${free_start}s" "${partition_end}" >> "$LOG_FILE" 2>&1
                rc=$?
                ;;
        esac
    fi

    echo $rc > "$RESULT_FILE"
    if [ $rc -ne 0 ]; then
        log_msg "Failed to create partition (rc=$rc) / Nie udało się utworzyć partycji (rc=$rc)"
        refresh_partitions "$disk"
        return $rc
    fi

    # Refresh and find created partition number / Odśwież i znajdź numer utworzonej partycji
    refresh_partitions "$disk"
    sleep 1
    last_part_num=$(get_last_partition_number "$disk" || true)
    if [ -n "$last_part_num" ]; then
        log_msg "Created partition number / Utworzono partycję numer: $last_part_num"
    fi

    # Print partition table to log / Wydrukuj tablicę partycji do loga
    /sbin/parted -s "$disk" print >> "$LOG_FILE" 2>&1 || true

    return 0
}

##################################################################################################################
# DELETE PARTITION / USUWANIE PARTYCJI
##################################################################################################################
# Arguments / Argumenty:
#   $1 - partition_path: full partition path / pełna ścieżka do partycji (np. /dev/sda1, /dev/nvme0n1p1)
#
# Examples / Przykłady wywołania:
#   delete_partition "/dev/sda1"     -> deletes /dev/sda1 / usuwa /dev/sda1
#   delete_partition "/dev/nvme0n1p2" -> deletes /dev/nvme0n1p2 / usuwa /dev/nvme0n1p2
#   delete_partition "/dev/mmcblk0p1" -> deletes /dev/mmcblk0p1 / usuwa /dev/mmcblk0p1
#
##################################################################################################################
delete_partition() {
    partition_path="$1"

    log_msg "=== Deleting partition / Usuwanie partycji: $partition_path ==="

    # Validate argument / Walidacja argumentu
    if [ -z "$partition_path" ]; then
        log_msg "ERROR: Missing partition path / BŁĄD: Brak ścieżki partycji"
        log_msg "Usage / Użycie: delete_partition <partition_path>"
        log_msg "Example / Przykład: delete_partition /dev/sda1"
        echo 1 > "$RESULT_FILE"
        return 1
    fi

    # Check if partition exists as block device / Sprawdź czy partycja istnieje jako urządzenie blokowe
    if [ ! -b "$partition_path" ]; then
        log_msg "ERROR: Partition $partition_path does not exist as block device / BŁĄD: Partycja $partition_path nie istnieje jako urządzenie blokowe"
        echo 1 > "$RESULT_FILE"
        return 1
    fi

    # Parse partition name to extract base device and number / Parsuj nazwę partycji aby wyodrębnić urządzenie bazowe i numer
    DEVICE=""
    NUM=""
    BNAME=$(basename "$partition_path")
    
    log_msg "Parsing partition name / Parsowanie nazwy partycji: $BNAME"
    
    # Handle different device types / Obsługa różnych typów urządzeń
    # Path starts with sdX (e.g., sda1, sdb2) / Ścieżka zaczyna się od sdX (np. sda1, sdb2)
    if [ "$BNAME" != "${BNAME#sd?}" ]; then
        if [ -z "${BNAME#sd?}" ]; then
            # Only sda without number - disk formatted without partition table
            # Tylko sda bez numeru - dysk sformatowany bez tablicy partycji
            DEVICE="/dev/$BNAME"
            NUM="1"
        else
            # sda1, sdb2, etc.
            DEVICE="/dev/${BNAME:0:3}"  # first 3 characters / pierwsze 3 znaki: sda
            NUM="${BNAME#sd?}"           # rest after sd? / reszta po sd?: 1, 2, etc.
        fi
    # Path starts with sataX (e.g., sataa1) / Ścieżka zaczyna się od sataX (np. sataa1)
    elif [ "$BNAME" != "${BNAME#sata?}" ]; then
        if [ -z "${BNAME#sata?}" ]; then
            DEVICE="/dev/$BNAME"
            NUM="1"
        else
            DEVICE="/dev/${BNAME:0:5}"  # first 5 characters / pierwsze 5 znaków: sataa
            NUM="${BNAME#sata?}"
        fi
    # Path starts with nvmeX (e.g., nvme0n1p1) / Ścieżka zaczyna się od nvmeX (np. nvme0n1p1)
    elif [ "$BNAME" != "${BNAME#nvme}" ]; then
        # nvme format: nvme0n1p1 -> DEVICE=/dev/nvme0n1 NUM=1
        DEVICE="/dev/${BNAME%%p*}"      # everything before 'p' / wszystko przed 'p'
        NUM="${BNAME##*p}"               # everything after last 'p' / wszystko po ostatnim 'p'
    # Path starts with mmcblkX (e.g., mmcblk1p1) / Ścieżka zaczyna się od mmcblkX (np. mmcblk1p1)
    elif [ "$BNAME" != "${BNAME#mmcblk?}" ]; then
        # mmcblk format: mmcblk1p1 -> DEVICE=/dev/mmcblk1 NUM=1
        DEVICE="/dev/${BNAME%%p*}"
        NUM="${BNAME##*p}"
    else
        log_msg "ERROR: Unsupported device naming / BŁĄD: Nieobsługiwane nazewnictwo urządzenia: $partition_path"
        echo 1 > "$RESULT_FILE"
        return 1
    fi

    log_msg "Parsed / Sparsowano: DEVICE=$DEVICE NUM=$NUM"

    # Validate that parsing succeeded / Walidacja że udało się sparsować
    if [ -z "$DEVICE" ] || [ -z "$NUM" ]; then
        log_msg "ERROR: Failed to parse device and partition number / BŁĄD: Nie udało się sparsować urządzenia i numeru partycji"
        echo 1 > "$RESULT_FILE"
        return 1
    fi

    # Validate that base device exists / Walidacja że urządzenie bazowe istnieje
    if [ ! -b "$DEVICE" ]; then
        log_msg "ERROR: Base device $DEVICE does not exist / BŁĄD: Urządzenie bazowe $DEVICE nie istnieje"
        echo 1 > "$RESULT_FILE"
        return 1
    fi

    # Verify partition exists in partition table / Sprawdź czy partycja istnieje w tablicy partycji
    if ! /sbin/parted -s -m "$DEVICE" print 2>/dev/null | grep -q "^${NUM}:"; then
        log_msg "ERROR: Partition $NUM does not exist on $DEVICE / BŁĄD: Partycja $NUM nie istnieje na $DEVICE"
        /sbin/parted -s "$DEVICE" print >> "$LOG_FILE" 2>&1 || true
        echo 1 > "$RESULT_FILE"
        return 1
    fi

    # Check if this is an extended partition / Sprawdź czy to partycja rozszerzona
    is_extended=""
    
    # Method 1: Check machine-readable format column 5
    is_extended=$(/sbin/parted -s -m "$DEVICE" print 2>/dev/null | awk -F: -v num="$NUM" '$1==num && tolower($5) ~ /extended/ {print "yes"}' || true)
    
    # Method 2: If empty, check column 6
    if [ -z "$is_extended" ]; then
        is_extended=$(/sbin/parted -s -m "$DEVICE" print 2>/dev/null | awk -F: -v num="$NUM" '$1==num && tolower($6) ~ /extended/ {print "yes"}' || true)
    fi
    
    # Method 3: If still empty, check regular output
    if [ -z "$is_extended" ]; then
        is_extended=$(/sbin/parted -s "$DEVICE" print 2>/dev/null | awk -v num="$NUM" '$1==num && tolower($5) ~ /extended/ {print "yes"}' || true)
    fi
    
    log_msg "Is extended partition / Czy partycja rozszerzona: '$is_extended'"

    # Unmount all partitions on this device / Odmontuj wszystkie partycje na tym urządzeniu
    unmount_device "$DEVICE"

    # Build full partition path for zeroing operations / Zbuduj pełną ścieżkę partycji dla operacji zerowania
    base_name=$(basename "$DEVICE")
    if [ "${base_name#nvme}" != "$base_name" ] || [ "${base_name#mmcblk}" != "$base_name" ]; then
        # Devices requiring 'p' separator / Urządzenia wymagające separatora 'p'
        partition_to_zero="${DEVICE}p${NUM}"
    else
        # Devices without separator / Urządzenia bez separatora
        partition_to_zero="${DEVICE}${NUM}"
    fi

    log_msg "Partition to zero / Partycja do wyzerowania: $partition_to_zero"

    if [ "$is_extended" = "yes" ]; then
        log_msg "SKIPPING zeroing for extended partition (contains only metadata) / POMIJANIE zerowania dla partycji rozszerzonej (zawiera tylko metadane)"
    else
        # Get partition size for proper zeroing / Pobierz rozmiar partycji dla prawidłowego zerowania
        SIZE_KB=$(grep "$(basename "$partition_to_zero")$" /proc/partitions 2>/dev/null | awk '{print $3}')
        
        if [ -n "$SIZE_KB" ]; then
            log_msg "Partition size / Rozmiar partycji: ${SIZE_KB}KB"
        else
            log_msg "Could not determine partition size from /proc/partitions / Nie można określić rozmiaru partycji z /proc/partitions"
        fi

        # Zero out partition to remove filesystem signatures / Wyzeruj partycję aby usunąć sygnatury systemu plików
        if [ -b "$partition_to_zero" ]; then
            log_msg "Zeroing partition $partition_to_zero before deletion / Zerowanie partycji $partition_to_zero przed usunięciem"
            
            if [ -n "$SIZE_KB" ] && [ "$SIZE_KB" -ne 0 ] && [ "$SIZE_KB" -lt 10240 ]; then
                # If partition is small (< 10MB), zero it completely / Jeśli partycja jest mała (< 10MB), wyzeruj całkowicie
                log_msg "Partition smaller than 10MB, zeroing completely / Partycja mniejsza niż 10MB, zerowanie całkowite (${SIZE_KB}KB)"
                dd if=/dev/zero of="$partition_to_zero" bs=1K count="$SIZE_KB" >> "$LOG_FILE" 2>&1 || true
            else
                # Zero first 10MB / Wyzeruj pierwsze 10MB
                log_msg "Zeroing first 10MB of partition / Zerowanie pierwszych 10MB partycji"
                dd if=/dev/zero of="$partition_to_zero" bs=1M count=10 >> "$LOG_FILE" 2>&1 || true
            fi
            sync
            sleep 1
        else
            log_msg "Warning: partition $partition_to_zero not found as block device, skipping zeroing / Ostrzeżenie: partycja $partition_to_zero nie znaleziona jako urządzenie blokowe, pomijanie zerowania"
        fi
    fi

    # Delete partition using parted on the base device / Usuń partycję używając parted na urządzeniu bazowym
    log_msg "Executing / Wykonywanie: parted -s $DEVICE rm $NUM"
    parted_cmd "$DEVICE" rm "$NUM" >> "$LOG_FILE" 2>&1
    rc=$?

    echo $rc > "$RESULT_FILE"

    if [ $rc -eq 0 ]; then
        log_msg "Partition $NUM deleted successfully from $DEVICE / Partycja $NUM usunięta pomyślnie z $DEVICE"
    else
        log_msg "FAILED to delete partition $NUM from $DEVICE (rc=$rc) / NIE UDAŁO SIĘ usunąć partycji $NUM z $DEVICE (rc=$rc)"
    fi

    # Force kernel to refresh partition table / Wymuś odświeżenie tablicy partycji przez kernel
    log_msg "Refreshing partition table on device $DEVICE / Odświeżanie tablicy partycji na urządzeniu $DEVICE"
    refresh_partitions "$DEVICE"
    
    # Additional aggressive refresh / Dodatkowe agresywne odświeżenie
    sync
    sleep 2
    
    if command -v partprobe >/dev/null 2>&1; then
        partprobe "$DEVICE" >> "$LOG_FILE" 2>&1 || true
    fi
    
    # NEW: Check if this was the last partition - if yes, remove partition table
    # NOWE: Sprawdź czy to była ostatnia partycja - jeśli tak, usuń tablicę partycji
    if ! disk_has_partitions "$DEVICE"; then
        log_msg "No partitions left on $DEVICE - removing partition table / Brak partycji na $DEVICE - usuwanie tablicy partycji"
        # Zero out the partition table area / Wyzeruj obszar tablicy partycji
        dd if=/dev/zero of="$DEVICE" bs=512 count=1 >> "$LOG_FILE" 2>&1 || true
        dd if=/dev/zero of="$DEVICE" bs=512 seek=1 count=2047 >> "$LOG_FILE" 2>&1 || true
        sync
        sleep 1
        # Final refresh / Finalne odświeżenie
        refresh_partitions "$DEVICE"
        log_msg "Partition table removed from $DEVICE / Tablica partycji usunięta z $DEVICE"
    else
        log_msg "Other partitions still exist on $DEVICE - keeping partition table / Inne partycje nadal istnieją na $DEVICE - zachowanie tablicy partycji"
    fi
    
    # Force a final sync / Wymuś finalne sync
    sync
    
    log_msg "Partition deletion completed with rc=$rc / Usuwanie partycji zakończone z rc=$rc"
    
    return $rc
}

##################################################################################################################
# FORMAT PARTITION / FORMATOWANIE PARTYCJI
##################################################################################################################
format_partition() {
    device="$1"
    fstype="$2"
    label="$3"

    log_msg "=== Formatting $device as $fstype / Formatowanie $device jako $fstype ==="

    if is_device_mounted "$device"; then
        umount -l "$device" >> "$LOG_FILE" 2>&1 || true
        sleep 1
    fi

    case "$fstype" in
        ext4|ext3|ext2)
            [ -n "$label" ] && mkfs.$fstype -F -L "$label" "$device" >> "$LOG_FILE" 2>&1 \
                             || mkfs.$fstype -F "$device" >> "$LOG_FILE" 2>&1
            ;;
        ntfs)
            [ -n "$label" ] && mkfs.ntfs -f -L "$label" "$device" >> "$LOG_FILE" 2>&1 \
                             || mkfs.ntfs -f "$device" >> "$LOG_FILE" 2>&1
            ;;
        vfat|fat32)
            [ -n "$label" ] && mkfs.fat -F 32 -n "$label" "$device" >> "$LOG_FILE" 2>&1 \
                             || mkfs.fat -F 32 "$device" >> "$LOG_FILE" 2>&1
            ;;
        f2fs)
            [ -n "$label" ] && mkfs.f2fs -f -l "$label" "$device" >> "$LOG_FILE" 2>&1 \
                             || mkfs.f2fs -f "$device" >> "$LOG_FILE" 2>&1
            ;;
        swap)
            [ -n "$label" ] && mkswap -L "$label" "$device" >> "$LOG_FILE" 2>&1 \
                             || mkswap "$device" >> "$LOG_FILE" 2>&1
            ;;
        exfat)
            [ -n "$label" ] && mkfs.exfat -n "$label" "$device" >> "$LOG_FILE" 2>&1 \
                             || mkfs.exfat "$device" >> "$LOG_FILE" 2>&1
            ;;
        *)
            log_msg "Unsupported filesystem / Nieobsługiwany system plików: $fstype"
            echo 1 > "$RESULT_FILE"
            return 1
            ;;
    esac

    rc=$?
    echo $rc > "$RESULT_FILE"

    base=$(echo "$device" | sed -E 's/p?[0-9]+$//')

    refresh_partitions "$base"

    return $rc
}

##################################################################################################################
# JSON API INTERFACE / INTERFEJS API JSON
##################################################################################################################
case "$1" in
    list)
        json_init
        json_add_object "create_partition"
            json_add_string "device" "string"
            json_add_string "type" "string"
            json_add_string "fstype" "string"
            json_add_string "size" "string"
            json_add_string "layout" "string"
            json_add_string "label" "string"
        json_close_object
        json_add_object "delete_partition"
            json_add_string "partition" "string"
        json_close_object
        json_add_object "format_partition"
            json_add_string "device" "string"
            json_add_string "fstype" "string"
            json_add_string "label" "string"
        json_close_object
        json_add_object "check_operation"
            json_add_string "pid" "string"
        json_close_object
        json_dump
        ;;

    call)
        case "$2" in

            create_partition)
                read input
                json_load "$input"
                json_get_var device device
                json_get_var type type
                json_get_var fstype fstype
                json_get_var size size
                json_get_var layout layout
                json_get_var label label

                (
                    create_partition_impl "$device" "$type" "${fstype:-ext2}" "${size:-0}" "${layout:-msdos}" "$label"
                    exit $?
                ) &
                pid=$!
                echo $pid > "$PID_FILE"

                json_init; json_add_boolean success 1; json_add_int pid $pid; json_dump
                ;;

            delete_partition)
                read input
                json_load "$input"
                json_get_var partition partition

                (
                    delete_partition "$partition"
                    exit $?
                ) &
                pid=$!
                echo $pid > "$PID_FILE"

                json_init; json_add_boolean success 1; json_add_int pid $pid; json_dump
                ;;

            format_partition)
                read input
                json_load "$input"
                json_get_var device device
                json_get_var fstype fstype
                json_get_var label label

                (
                    format_partition "$device" "$fstype" "$label"
                    exit $?
                ) &
                pid=$!
                echo $pid > "$PID_FILE"

                json_init; json_add_boolean success 1; json_add_int pid $pid; json_dump
                ;;

            check_operation)
                read input
                json_load "$input"
                json_get_var pid pid

                if kill -0 "$pid" 2>/dev/null; then
                    json_init; json_add_boolean running 1; json_dump
                else
                    result=1
                    [ -f "$RESULT_FILE" ] && result=$(cat "$RESULT_FILE")
                    log=$(tail -n 200 "$LOG_FILE" 2>/dev/null)

                    json_init
                    json_add_boolean running 0
                    json_add_int exitcode $result
                    json_add_string log "$log"
                    json_dump

                    rm -f "$PID_FILE" "$RESULT_FILE"
                fi
                ;;

        esac
        ;;
esac
